## Реализация
* При реализации кэша использовались 2 взаимосвязанные структуры данных:
  * двухсвязный список, ноды в котором были представлены типом NodeValue
  * Мапа,  в качестве ключа в которой использовался ключ для кэша, а в качестве значения ссылка на ноду. 
```go
type  NodeValue  struct{
key  interface{}
value  interface{}
intCh  chan  struct{}
}
```
* В момент добавления элемент помещается в конец двухсвязного списка. В момент, когда количество элементов в кэше превышает его максимальный размер удаляется первый элемент двухсвязного списка. Элемент, к которому было обращение перемещается в конец списка. Подобная реализация позволяет выполнять операции добавления, удаления и получения элементов за константное время. 
* Благодаря использованию мьютексов данная реализация кэша является потокобезопасной.
## Поддерживаемые команды:
### Получение размера кэша
``` go
func (c *LRU_Cache)Cap() int
```
 Данная функция возвращает вместимость кэша.
 ### Очистка кэша
 ```go
 func (c *LRU_Cache)Clear()
 ```
  Данная функция полностью очищает кэш.
  ### Удаление элемента по ключу
  ```go
  func (c *LRU_Cache)Remove(key  interface{}) error
  ```
 
 ### Добавление элемента
 ```go
 func (c *LRU_Cache)Add(key, value  interface{})
 ```
 Данная функция добавляет элемент с ключом key и значением value.
 Если элемент с таким ключом уже присутствует, то его значение будет перезаписано. Если после добавления число элментов в кэше превысит его вместимость, то будет удален первый элемент двухсвязного списка.
 ### Получение данных по ключу
 ```go
 func (c *LRU_Cache)Get(key  interface{}) (value  interface{}, ok  bool)
 ```
 Данная функция возвращает значение, которое соответствует переданному ключу. Элемент, к которому было обращение перемещается в конец двухсвязного списка. 
 ### Добавление элемента с тайм лимитом
 ```go
func (c *LRU_Cache)AddWithTTL(key, value  interface{}, ttl  time.Duration)
```
Данная функция добавляет элемент, который будет удален через время - ttl. 